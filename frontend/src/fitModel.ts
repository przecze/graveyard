/**
 * Deaths-per-year model.
 *
 * Pre-1950: piecewise quadratic fit in log-time u = ln(K − t).
 *   Generated by geo/death_model.py (fit_deaths_direct / export_deaths_curve).
 *   Stored as [[year, deaths_per_year], ...] in deathsModel.json.
 *   C¹-continuous at period boundaries; 0.0000% error on all period integrals.
 *
 * For 1950+: actual annual deaths from UN World Population Prospects 2024
 *   (see deathsOwid.ts).
 *
 * PRB reference data (PRB_TABLE, prbIntervals, prbCBR) is kept for the
 * era-summary table display in PopulationChart.
 */

import deathsModelRaw from './deathsModel.json';

// ----------------------------------------------------------------
// Constants
// ----------------------------------------------------------------

export const DATA_START = -8000;    // 8 000 BCE = start of ring model
export const PRESENT_YEAR = 2026;

// ----------------------------------------------------------------
// PRB 2022 Table 1 — full reference data
// "Births Between Benchmarks" are the published PRB values.
// Population benchmarks are also from PRB Table 1.
// ----------------------------------------------------------------

export interface PrbEntry {
  year: number;
  pop: number;
  /** Births (≈ deaths) from the PREVIOUS benchmark to this one. */
  births: number;
}

export const PRB_TABLE: PrbEntry[] = [
  { year: -190000, pop:             2, births:              0 },
  { year:  -50000, pop:   2_000_000,  births:  7_856_100_000 },
  { year:   -8000, pop:   5_000_000,  births:  1_137_789_769 },
  { year:       1, pop: 300_000_000,  births: 46_025_332_354 },
  { year:    1200, pop: 450_000_000,  births: 26_591_343_000 },
  { year:    1650, pop: 500_000_000,  births: 12_782_002_453 },
  { year:    1750, pop: 795_000_000,  births:  3_171_931_513 },
  { year:    1850, pop: 1_265_000_000, births: 4_046_240_009 },
  { year:    1900, pop: 1_656_000_000, births: 2_900_237_856 },
  { year:    1950, pop: 2_499_000_000, births: 3_390_198_215 },
  { year:    2000, pop: 6_149_000_000, births: 6_064_994_884 },
  { year:    2010, pop: 6_986_000_000, births: 1_364_003_405 },
  { year:    2022, pop: 7_963_500_000, births: 1_690_275_115 },
];

/**
 * Total births (≈ deaths) before 8 000 BCE — the "ancient circle" graves.
 * = PRB "Number Ever Born" at 8 000 BCE = sum of all births up to that point.
 */
export const ANCIENT_GRAVES: number =
  PRB_TABLE[1].births +   // 190 000 BCE → 50 000 BCE
  PRB_TABLE[2].births;    // 50 000 BCE  →  8 000 BCE
// = 8 993 889 769 ≈ 8 993 889 771 (PRB rounding)

// ----------------------------------------------------------------
// PRB intervals — the ring model covers DATA_START (−8000) to 1950.
//
// Each interval [startYear, endYear] uses PRB's own population
// benchmarks and the "Births Between Benchmarks" total from Table 1.
// The growth rate g is derived directly from the two benchmark pops.
// ----------------------------------------------------------------

export interface PrbInterval {
  startYear: number;
  endYear: number;
  startPop: number;
  endPop: number;
  /**
   * Estimated deaths in this interval = PRB births − ΔPop.
   * PRB publishes births (not deaths); deaths ≈ births for slow-growth eras
   * but diverges by up to 25% for the fast-growing 1750–1950 period.
   */
  births: number;
  /** Exponential growth rate: ln(endPop/startPop) / (endYear − startYear). */
  g: number;
}

export const prbIntervals: PrbInterval[] = (() => {
  // Only intervals that fall within our ring model (DATA_START → 1950)
  const milestones = PRB_TABLE.filter(e => e.year >= DATA_START && e.year <= 1950);
  const result: PrbInterval[] = [];
  for (let i = 0; i < milestones.length - 1; i++) {
    const a = milestones[i];
    const b = milestones[i + 1];
    const T = b.year - a.year;
    const g = Math.log(b.pop / a.pop) / T;
    // PRB "births" are births, not deaths.  Actual deaths = births − ΔPop.
    // For ancient intervals ΔPop ≪ births so the correction is negligible (<1%).
    // For 1750–1950 population grew fast, so this matters (up to 25% for 1900–1950).
    const deaths = b.births - (b.pop - a.pop);
    result.push({
      startYear: a.year,
      endYear:   b.year,
      startPop:  a.pop,
      endPop:    b.pop,
      births:    deaths,   // field reused for deaths total; label updated below
      g,
    });
  }
  return result;
})();

// ----------------------------------------------------------------
// PRB formula — kept for the era-table display in PopulationChart.
// ----------------------------------------------------------------

export function prbDeathsPerYear(year: number): number {
  for (const iv of prbIntervals) {
    if (year >= iv.startYear && year < iv.endYear) {
      const t = year - iv.startYear;
      if (Math.abs(iv.g) < 1e-12) {
        return iv.births / (iv.endYear - iv.startYear);
      }
      const Pt = iv.startPop * Math.exp(iv.g * t);
      return iv.births * iv.g * Pt / (iv.endPop - iv.startPop);
    }
  }
  const last = prbIntervals[prbIntervals.length - 1];
  return last.births * last.g * last.endPop / (last.endPop - last.startPop);
}

// ----------------------------------------------------------------
// Model deaths-per-year: piecewise quadratic fit in log-time.
// Loaded from deathsModel.json (written by geo/death_model.py).
// ----------------------------------------------------------------

const _modelMap = new Map<number, number>(
  (deathsModelRaw as [number, number][]).map(([y, d]) => [y, d]),
);
const _modelMin = (deathsModelRaw as [number, number][])[0][0];
const _modelMax = (deathsModelRaw as [number, number][])[(deathsModelRaw as [number, number][]).length - 1][0];

/**
 * Deaths per year at calendar year `year`, using the fitted model for
 * years within the model range and clamping to boundary values outside it.
 *
 * Used by graveyard.ts and PopulationChart.tsx for pre-1950 values.
 * For 1950+ the callers prefer OWID actual data over this function.
 */
export function cbrDeathsPerYear(year: number): number {
  const y = Math.round(year);
  if (y <= _modelMin) return _modelMap.get(_modelMin) ?? 0;
  if (y >= _modelMax) return _modelMap.get(_modelMax) ?? 0;
  return _modelMap.get(y) ?? _modelMap.get(y - 1) ?? _modelMap.get(y + 1) ?? 0;
}

// Needed by PopulationChart PrbEraTable — stub returning NaN for 1950+
export function prbCBR(year: number): number {
  for (const iv of prbIntervals) {
    if (year >= iv.startYear && year < iv.endYear) {
      // Implied CBR from the PRB data: births = CBR/1000 · person-years
      // person-years = (P1−P0)/g
      const personYears = (iv.endPop - iv.startPop) / iv.g;
      return iv.births / personYears * 1000;
    }
  }
  return NaN;
}

// Dummy — no longer used, kept so old imports don't break
export function interpOwidPop(_year: number): number { return NaN; }

// Legacy
export const prbEntries = PRB_TABLE.filter(e => e.year >= DATA_START);
